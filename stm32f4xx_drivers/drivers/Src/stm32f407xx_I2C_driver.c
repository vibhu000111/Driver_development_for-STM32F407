/*
 * stm32f407xx_I2C_driver.c
 *
 *  Created on: 17-Jan-2025
 *      Author: vibhu
 */

#include <stm32f4xx_I2C_driver.h>
#include <stm32f407xx.h>

static void I2C_Gen_Start(I2C_RegDef_t *pI2Cx);
static void I2C_ExecuteAddressPhase(I2C_RegDef_t *pI2Cx,uint8_t SlaveAddr);
static void ClearAddrFlag(I2C_RegDef_t *pI2Cx);
static void I2C_Gen_Stop(I2C_RegDef_t *pI2Cx);
uint16_t factor_AHB[] ={2,4,8,16,64,128,256,512};
uint8_t factor_APB1[] ={2,4,8,16};
uint32_t getPCLK1Freq() // pg 154 of reference manual
{

	//clk sources can be HSE,HSI OR PLLCLK
	//whatever clock is selected is prescaled by AHB prescaler and then APB prescaler

	//clk source
	uint32_t SystemClk;

	uint8_t clksource = ((RCC->RCC_CFGR >> 2) & 0x03); // gives value of SWS0 AND SWS1

	if(clksource ==0)
	{
		SystemClk = 16000000;
	}
	else if(clksource == 1)
	{
		SystemClk = 8000000;
	}
	//No support for PLL

	//Now get the value of AHB prescaler

	uint8_t AHBprescalefactor =((RCC->RCC_CFGR >> 4) & 0x0f);

	if(AHBprescalefactor < 8)
	{
		SystemClk = SystemClk/1;
	}
	else if(AHBprescalefactor >=8)
	{
		SystemClk = SystemClk/(factor_AHB[8 - AHBprescalefactor]);
	}
	//As all I2C peripherals are connected to apb1 BUS
	uint8_t APB1_prescaler = (RCC->RCC_CFGR >> 10) & 0x07; //extract the the bits for prescaler factor

	if(APB1_prescaler<4)
	{
		SystemClk = SystemClk/1;
	}
	else if(APB1_prescaler>=4)
	{
		SystemClk = SystemClk/(factor_APB1[APB1_prescaler - 4]);
	}




	return(SystemClk);
}
void I2C_Peripehral_clk_control(I2C_RegDef_t *I2Cpx,uint8_t EnDi)
{
	if(EnDi == ENABLE)
	{
		if(I2Cpx == I2C1 )
		{
			I2C1_PCLK_EN();
		}
		else if (I2Cpx == I2C2)
		{
			I2C2_PCLK_EN();
		}
		else if (I2Cpx == I2C3)
		{
			I2C3_PCLK_EN();
		}
	}
	else if(EnDi == DISABLE)
	{
		if(I2Cpx == I2C1 )
		{
			I2C1_PCLK_EN();
		}
		else if (I2Cpx == I2C2)
		{
			I2C2_PCLK_EN();
		}
		else if (I2Cpx == I2C3)
		{
			I2C3_PCLK_EN();
		}
	}
}
void I2C_EnDi(I2C_RegDef_t *pI2Cx , uint8_t EnDi)
{
	if(EnDi == ENABLE)
	{
		pI2Cx->I2C_CR1|=(1<<I2C_PE);
	}
	else if (EnDi == DISABLE)
	{
		pI2Cx->I2C_CR1 &=~(1<<I2C_PE);
	}
}
void I2C_init(I2C_handle_t *pI2Chandle)
{
	I2C_Peripehral_clk_control(pI2Chandle->pI2Cx,ENABLE);
	uint32_t tempreg = 0;
	tempreg |= (pI2Chandle->I2C_config_params.I2C_ACKControl << I2C_ACK);
	pI2Chandle->pI2Cx->I2C_CR1 = tempreg;
	uint32_t k = getPCLK1Freq(); // get clock  frequency at which APB1 bus is operating

	//configure freq field
	uint8_t freq;
	if(k>1000000 && k <= 42000000)// pclk freq should be less than 42 MHz
	{
		freq = k/1000000U; // to get clock in MHZ therefore freq is in the range of 1 to 42 Mhz
		pI2Chandle->pI2Cx->I2C_CR2 |=((freq & 0x3f) << 0);
	}

	// store slave 7 bit OAR1 register and configure OAR1 register check the register layout in reference manual
	tempreg=0;
	tempreg |= (pI2Chandle->I2C_config_params.DeviceAddress << 1);
	tempreg |= (1<<14); //as per the reference manual
	tempreg &=~(1<<15);
	pI2Chandle->pI2Cx->I2C_OAR1 = tempreg;
	tempreg=0;
	//CCR calculations - 191
	uint16_t ccr_value=0;

	if(pI2Chandle->I2C_config_params.I2C_SCLSpeed <= I2C_SCL_SPEED_SM) // then configure the ccr to operate in SM
	{
		//mode SM ie 15th bit in CCR reg
		//pI2Chandle->pI2Cx->I2C_CCR&=~(1<<15); //configure the 15th bit from SM
		//if Thigh == Tlow 50% duty then Tscl = 2*CCR *Tpclk1 therefore ccr = Tscl/2*Tpclk1
		// ccr = Fpclk1 / 2*Fscl
		ccr_value = k / (2 * pI2Chandle->I2C_config_params.I2C_SCLSpeed);
		tempreg|=(ccr_value & 0xfff); // as CCR value is 12 bit
	}
	else
	{
		tempreg|=(1<<15);
		tempreg|=(pI2Chandle->I2C_config_params.I2C_FMDutyCycle << 14);
		if(pI2Chandle->I2C_config_params.I2C_FMDutyCycle == I2C_FM_DUTY_2)
		{
			ccr_value = k / (3 * pI2Chandle->I2C_config_params.I2C_SCLSpeed);

		}
		else
		{
			ccr_value = k / (25 * pI2Chandle->I2C_config_params.I2C_SCLSpeed);
		}
		tempreg|=(ccr_value & 0xfff);

	}
	pI2Chandle->pI2Cx->I2C_CCR= tempreg;
	//trise register left
	//[Fpclk1 * Trise(max)] + 1
	tempreg=0;
	if(pI2Chandle->I2C_config_params.I2C_SCLSpeed <= I2C_SCL_SPEED_SM)
	{
		tempreg= (k/1000000U) + 1;
	}
	else
	{
		tempreg= ((k*300)/1000000000U) + 1;
	}
	pI2Chandle->pI2Cx->I2C_TRISE = (tempreg & 0x3f);

}
void I2C_MasterSendData(I2C_handle_t *pI2Chandle, uint8_t *pTxBuffer ,uint32_t Len, uint8_t SlaveAddr)
{
	// Gen start Condition

	I2C_Gen_Start(pI2Chandle->pI2Cx);
	// Confirm that the start condition is generated by checking the SB flag in the SR1
	//Until SB is cleared SCL will b stretched (pulled to low)
	while(I2C_GetFlagStatus(pI2Chandle->pI2Cx , I2C_FLAG_SB) == 0); // wait till SB is set
	// Send the address of the slave with read write bit set to write(0) total 8 bits
	I2C_ExecuteAddressPhase(pI2Chandle->pI2Cx,SlaveAddr);

	// check the address phase is completed by checking the ADDR flag in the status register
	while(I2C_GetFlagStatus(pI2Chandle->pI2Cx , I2C_FLAG_ADDR) == 0);
	ClearAddrFlag(pI2Chandle->pI2Cx);
	// Send Data until length becomes zero
	while(Len>0)
	{
		while(I2C_GetFlagStatus(pI2Chandle->pI2Cx , I2C_FLAG_TXE) == 0); //wait till TXE is set
		pI2Chandle->pI2Cx->I2C_DR = *pTxBuffer;
		Len--;
		pTxBuffer++;

	}
	while(I2C_GetFlagStatus(pI2Chandle->pI2Cx , I2C_FLAG_TXE) == 0); // wait till TXE is set
	while(I2C_GetFlagStatus(pI2Chandle->pI2Cx , I2C_FLAG_BTF) == 0); // wait till BTF is set
	I2C_Gen_Stop(pI2Chandle->pI2Cx);




}
static void I2C_Gen_Start(I2C_RegDef_t *pI2Cx)
{
	pI2Cx->I2C_CR1|= (1 << I2C_START);
}
uint8_t I2C_GetFlagStatus(I2C_RegDef_t* pI2Cx,uint32_t FlagName)
{
	if(pI2Cx->I2C_SR1 & FlagName)
	{
		return(1);
	}
		return(0);

}
static void I2C_ExecuteAddressPhase(I2C_RegDef_t *pI2Cx,uint8_t SlaveAddr)
{
	SlaveAddr = SlaveAddr << 1;
	SlaveAddr &= ~(1<<0);
	pI2Cx->I2C_DR = SlaveAddr;

}
static void ClearAddrFlag(I2C_RegDef_t *pI2Cx)
{
	uint32_t dummyread = pI2Cx->I2C_SR1;
	dummyread = pI2Cx->I2C_SR2;
}
static void I2C_Gen_Stop(I2C_RegDef_t *pI2Cx)
{
	pI2Cx->I2C_CR1|= (1 << I2C_STOP);
}
